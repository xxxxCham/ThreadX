"""
ThreadX Data Copier - Utilitaire de copie des donn√©es locales
Copie les donn√©es depuis les sources externes vers l'espace de travail ThreadX
"""

import shutil
import json
from pathlib import Path
from typing import Dict, Any
import logging
from datetime import datetime

logger = logging.getLogger(__name__)


class ThreadXDataCopier:
    """Utilitaire pour copier les donn√©es dans l'espace de travail ThreadX"""

    def __init__(self, threadx_root: str = "D:\\ThreadX"):
        self.threadx_root = Path(threadx_root)
        self.data_root = self.threadx_root / "data"

        # Sources de donn√©es d√©couvertes
        self.sources = {
            "indicators_cache": Path("D:\\ThreadX\\indicators_cache"),
            "trading_data": Path("d:\\Tools\\dataframe\\parquet"),
            # Ajouter d'autres sources si d√©couvertes
        }

        # Destinations dans ThreadX
        self.destinations = {
            "indicators_cache": self.data_root / "raw" / "indicators_cache",
            "trading_data": self.data_root / "raw" / "trading_json",
        }

    def setup_data_structure(self) -> bool:
        """Cr√©er la structure de donn√©es ThreadX"""
        logger.info("üìÅ Cr√©ation de la structure de donn√©es ThreadX...")

        directories = [
            self.data_root,
            self.data_root / "raw",
            self.data_root / "processed",
            self.data_root / "indicators",
            self.data_root / "raw" / "indicators_cache",
            self.data_root / "raw" / "trading_json",
            self.data_root / "cache",
            self.data_root / "exports",
        ]

        try:
            for directory in directories:
                directory.mkdir(parents=True, exist_ok=True)
                logger.debug(f"‚úÖ Cr√©√©: {directory}")

            # Cr√©er un README dans data/
            self._create_data_readme()

            logger.info("‚úÖ Structure de donn√©es cr√©√©e avec succ√®s")
            return True

        except Exception as e:
            logger.error(f"‚ùå Erreur cr√©ation structure: {e}")
            return False

    def copy_indicators_cache(self) -> Dict[str, Any]:
        """Copier le cache d'indicateurs ThreadX existant"""
        source = self.sources["indicators_cache"]
        destination = self.destinations["indicators_cache"]

        logger.info("üìä Copie du cache d'indicateurs...")
        logger.info(f"   Source: {source}")
        logger.info(f"   Destination: {destination}")

        result: Dict[str, Any] = {
            "success": False,
            "files_copied": 0,
            "total_size_mb": 0.0,
            "error": None,
        }

        if not source.exists():
            result["error"] = f"Source inexistante: {source}"
            logger.warning(result["error"])
            return result

        try:
            # Nettoyer la destination si elle existe
            if destination.exists():
                logger.info("üßπ Nettoyage destination existante...")
                shutil.rmtree(destination)

            # Copier r√©cursivement
            shutil.copytree(source, destination)

            # Calculer les statistiques
            stats = self._calculate_directory_stats(destination)
            result.update(stats)
            result["success"] = True

            logger.info(
                f"‚úÖ Cache copi√©: {result['files_copied']} fichiers, "
                f"{result['total_size_mb']:.1f} MB"
            )

        except Exception as e:
            result["error"] = str(e)
            logger.error(f"‚ùå Erreur copie cache: {e}")

        return result

    def copy_trading_data(self) -> Dict[str, Any]:
        """Copier les donn√©es de trading JSON"""
        source = self.sources["trading_data"]
        destination = self.destinations["trading_data"]

        logger.info("üí∞ Copie des donn√©es de trading...")
        logger.info(f"   Source: {source}")
        logger.info(f"   Destination: {destination}")

        result: Dict[str, Any] = {
            "success": False,
            "files_copied": 0,
            "total_size_mb": 0.0,
            "error": None,
            "symbols": [],
            "timeframes": [],
        }

        if not source.exists():
            result["error"] = f"Source inexistante: {source}"
            logger.warning(result["error"])
            return result

        try:
            # Cr√©er la destination
            destination.mkdir(parents=True, exist_ok=True)

            # Copier les fichiers JSON
            symbols = set()
            timeframes = set()
            files_copied = 0
            total_size = 0

            for file_path in source.glob("*.json"):
                dest_file = destination / file_path.name
                shutil.copy2(file_path, dest_file)

                # Parser le nom pour extraire symbol/timeframe
                name_parts = file_path.stem.split("_")
                if len(name_parts) >= 2:
                    symbols.add(name_parts[0])
                    timeframes.add(name_parts[1])

                files_copied += 1
                total_size += file_path.stat().st_size

                if files_copied % 50 == 0:
                    logger.info(f"   üì• {files_copied} fichiers copi√©s...")

            result.update(
                {
                    "success": True,
                    "files_copied": files_copied,
                    "total_size_mb": total_size / (1024 * 1024),
                    "symbols": sorted(list(symbols)),
                    "timeframes": sorted(list(timeframes)),
                }
            )

            logger.info(
                f"‚úÖ Trading data copi√©e: {files_copied} fichiers, "
                f"{result['total_size_mb']:.1f} MB"
            )
            logger.info(
                f"   üìà {len(symbols)} symboles, " f"{len(timeframes)} timeframes"
            )

        except Exception as e:
            result["error"] = str(e)
            logger.error(f"‚ùå Erreur copie trading: {e}")

        return result

    def copy_all_data(self) -> Dict[str, Any]:
        """Copier toutes les donn√©es disponibles"""
        logger.info("üöÄ D√©but de la copie compl√®te des donn√©es...")

        # Cr√©er la structure
        if not self.setup_data_structure():
            return {"success": False, "error": "√âchec cr√©ation structure"}

        # Copier chaque source
        results: Dict[str, Any] = {
            "success": True,
            "timestamp": datetime.now().isoformat(),
            "total_files": 0,
            "total_size_mb": 0.0,
            "sources": {},
        }

        # Cache d'indicateurs
        cache_result = self.copy_indicators_cache()
        results["sources"]["indicators_cache"] = cache_result
        if cache_result["success"]:
            results["total_files"] += cache_result["files_copied"]
            results["total_size_mb"] += cache_result["total_size_mb"]

        # Donn√©es de trading
        trading_result = self.copy_trading_data()
        results["sources"]["trading_data"] = trading_result
        if trading_result["success"]:
            results["total_files"] += trading_result["files_copied"]
            results["total_size_mb"] += trading_result["total_size_mb"]

        # V√©rifier le succ√®s global
        results["success"] = any(
            source["success"] for source in results["sources"].values()
        )

        if results["success"]:
            logger.info("üéâ Copie termin√©e avec succ√®s!")
            logger.info(f"   üìä Total: {results['total_files']} fichiers")
            logger.info(f"   üíæ Taille: {results['total_size_mb']:.1f} MB")

            # Cr√©er un rapport de copie
            self._create_copy_report(results)
        else:
            logger.error("‚ùå √âchec de la copie globale")

        return results

    def _calculate_directory_stats(self, directory: Path) -> Dict[str, Any]:
        """Calculer les statistiques d'un r√©pertoire"""
        stats = {"files_copied": 0, "total_size_mb": 0.0, "directories": 0}

        for item in directory.rglob("*"):
            if item.is_file():
                stats["files_copied"] += 1
                stats["total_size_mb"] += item.stat().st_size / (1024 * 1024)
            elif item.is_dir():
                stats["directories"] += 1

        return stats

    def _create_data_readme(self):
        """Cr√©er un README dans le dossier data/"""
        readme_content = """# ThreadX Data Directory

## üìÅ Structure
```
data/
‚îú‚îÄ‚îÄ raw/                    # Donn√©es brutes copi√©es (NE PAS MODIFIER)
‚îÇ   ‚îú‚îÄ‚îÄ indicators_cache/   # Cache ThreadX existant
‚îÇ   ‚îî‚îÄ‚îÄ trading_json/       # Donn√©es de trading JSON
‚îú‚îÄ‚îÄ processed/              # Donn√©es trait√©es par ThreadX
‚îú‚îÄ‚îÄ indicators/             # IndicatorBank final
‚îú‚îÄ‚îÄ cache/                  # Cache de calcul
‚îî‚îÄ‚îÄ exports/                # Exports utilisateur
```

## ‚ö†Ô∏è Important
- **NE PAS COMMITTER** ces donn√©es sur Git
- Les donn√©es raw/ sont des **copies de sauvegarde**
- Les sources originales restent intactes
- Utiliser ThreadX Data Manager pour la gestion

## üîÑ Mise √† jour
Pour recopier les donn√©es depuis les sources:
```bash
python -m apps.data_manager.data_copier
```

## üìä Derni√®re copie
Voir `copy_report.json` pour les d√©tails de la derni√®re copie.
"""

        readme_path = self.data_root / "README.md"
        with open(readme_path, "w", encoding="utf-8") as f:
            f.write(readme_content)

    def _create_copy_report(self, results: Dict[str, Any]):
        """Cr√©er un rapport de copie"""
        report_path = self.data_root / "copy_report.json"
        with open(report_path, "w", encoding="utf-8") as f:
            json.dump(results, f, indent=2, ensure_ascii=False, default=str)

        logger.info(f"üìã Rapport de copie cr√©√©: {report_path}")

    def get_local_data_info(self) -> Dict[str, Any]:
        """Obtenir des informations sur les donn√©es locales copi√©es"""
        info = {
            "data_root": str(self.data_root),
            "exists": self.data_root.exists(),
            "sources_available": [],
        }

        if info["exists"]:
            for name, path in self.destinations.items():
                if path.exists():
                    stats = self._calculate_directory_stats(path)
                    info["sources_available"].append(
                        {
                            "name": name,
                            "path": str(path),
                            "files": stats["files_copied"],
                            "size_mb": round(stats["total_size_mb"], 2),
                        }
                    )

        return info


def main():
    """Point d'entr√©e principal"""
    logging.basicConfig(
        level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
    )

    print("üöÄ ThreadX Data Copier")
    print("=" * 50)

    copier = ThreadXDataCopier()

    # V√©rifier l'√©tat actuel
    info = copier.get_local_data_info()
    print(f"üìÅ R√©pertoire data: {info['data_root']}")
    print(f"   Existe: {'‚úÖ' if info['exists'] else '‚ùå'}")

    if info["sources_available"]:
        print("üìä Sources d√©j√† copi√©es:")
        for source in info["sources_available"]:
            print(
                f"   - {source['name']}: {source['files']} fichiers "
                f"({source['size_mb']} MB)"
            )

    # Demander confirmation pour la copie
    print("\n" + "=" * 50)
    print("‚ö†Ô∏è  ATTENTION: Cette op√©ration va copier les donn√©es")
    print("   dans l'espace de travail ThreadX local.")
    print("   Les donn√©es ne seront PAS commit√©es sur Git.")

    response = input("\nü§î Proc√©der √† la copie? (y/N): ").lower().strip()

    if response in ("y", "yes", "oui"):
        print("\nüîÑ D√©but de la copie...")
        results = copier.copy_all_data()

        if results["success"]:
            print("\nüéâ Copie termin√©e avec succ√®s!")
            print(f"üìä {results['total_files']} fichiers copi√©s")
            print(f"üíæ {results['total_size_mb']:.1f} MB")
        else:
            print("\n‚ùå √âchec de la copie. Voir les logs pour plus de d√©tails.")
    else:
        print("\n‚èπÔ∏è  Copie annul√©e.")


if __name__ == "__main__":
    main()
