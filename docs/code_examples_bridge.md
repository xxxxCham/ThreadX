# üìù CODE EXAMPLES - √âtat actuel vs Futur Bridge

**Objectif** : Montrer comment le code actuel appelle directement le moteur et comment cela changera avec Bridge

---

## üîç EXEMPLE 1 : Backtest avec Bollinger Bands

### ‚ùå Code actuel (appels directs Engine)

**Fichier** : `src/threadx/benchmarks/run_backtests.py` (lignes 122-145)

```python
from threadx.backtest import create_engine
from threadx.indicators import get_gpu_accelerated_bank

# Initialisation directe du moteur
engine = create_engine()
bank = get_gpu_accelerated_bank()

# G√©n√©ration donn√©es synth√©tiques
df = _generate_synthetic_data(size=1000)

# Configuration strat√©gie
strategy_name = "bollinger_mean_reversion"
params = {
    'entry_z': -2.0,
    'exit_z': 0.0,
    'atr_filter': True
}

# Ex√©cution directe (bloquante)
result = engine.run(
    data=df,
    strategy=strategy_name,
    params=params,
    use_gpu=False
)

# Acc√®s direct aux r√©sultats
cpu_equity_hash = hash_series(result.equity)
print(f"Total Return: {result.total_return:.2%}")
print(f"Sharpe: {result.sharpe_ratio:.2f}")
```

**Probl√®mes identifi√©s** :
- ‚ùå Import direct `threadx.backtest` dans code client
- ‚ùå Gestion manuelle initialisation Engine
- ‚ùå Ex√©cution bloquante (synchrone)
- ‚ùå Pas de validation params centralis√©e
- ‚ùå Testabilit√© difficile (mock Engine complexe)

---

### ‚úÖ Code futur (via Bridge)

**Fichier** : `apps/cli.py` ou `apps/benchmark.py` (apr√®s Prompt 2)

```python
from threadx.bridge import BacktestController, BacktestRequest

# Initialisation controller (une seule fois, config auto)
controller = BacktestController()

# Requ√™te d√©clarative avec validation int√©gr√©e
request = BacktestRequest(
    symbol='SYNTHETIC',
    timeframe='1h',
    data=df,  # DataFrame d√©j√† charg√©
    strategy='bollinger_mean_reversion',
    strategy_params={
        'entry_z': -2.0,
        'exit_z': 0.0,
        'atr_filter': True
    },
    use_gpu=False,
    initial_capital=10000.0
)

# Ex√©cution via Bridge (validation + orchestration)
result = controller.run_backtest(request)

# R√©sultat typ√© avec metadata
print(f"Total Return: {result.total_return:.2%}")
print(f"Sharpe: {result.sharpe_ratio:.2f}")
print(f"Execution Time: {result.metadata['execution_time_ms']}ms")
print(f"Cache Hits: {result.metadata['indicator_cache_hits']}")
```

**Avantages** :
- ‚úÖ Z√©ro import Engine (d√©couplage total)
- ‚úÖ Validation automatique via DataClass
- ‚úÖ Controller g√®re initialisation
- ‚úÖ Metadata enrichies (timing, cache, etc.)
- ‚úÖ Tests faciles (mock BacktestController)

---

## üîç EXEMPLE 2 : Construction indicateurs avec cache

### ‚ùå Code actuel (appels directs IndicatorBank)

**Fichier** : Hypoth√©tique dans UI/CLI

```python
from threadx.indicators.bank import IndicatorBank, ensure_indicator
import pandas as pd

# Initialisation manuelle
bank = IndicatorBank(cache_dir="indicators_cache")

# Chargement donn√©es
df = pd.read_parquet("data/BTCUSDC_15m.parquet")
close_prices = df['close']

# Ensure indicateur (cache ou calcul)
bb_result = ensure_indicator(
    indicator_name='bollinger',
    params={'period': 20, 'std': 2.0},
    data=close_prices,
    symbol='BTCUSDC',
    timeframe='15m'
)

# Acc√®s valeurs
upper_band = bb_result['upper']
middle_band = bb_result['middle']
lower_band = bb_result['lower']

print(f"Bollinger Bands computed: {len(upper_band)} values")
```

**Probl√®mes identifi√©s** :
- ‚ùå Import direct `IndicatorBank`
- ‚ùå Gestion manuelle cache_dir
- ‚ùå Pas de validation params
- ‚ùå Pas de metadata sur cache hit/miss
- ‚ùå Code r√©p√©titif pour batch indicators

---

### ‚úÖ Code futur (via Bridge)

```python
from threadx.bridge import IndicatorController, IndicatorRequest

# Initialisation (config auto depuis settings)
controller = IndicatorController()

# Requ√™te d√©clarative
request = IndicatorRequest(
    indicator_type='bollinger',
    params={'period': 20, 'std': 2.0},
    data=close_prices,
    symbol='BTCUSDC',
    timeframe='15m',
    force_recompute=False  # Utilise cache si disponible
)

# Ex√©cution via Bridge
result = controller.build_indicators(request)

# R√©sultat typ√© avec metadata cache
upper_band = result.values['upper']
middle_band = result.values['middle']
lower_band = result.values['lower']

print(f"Bollinger Bands computed: {len(upper_band)} values")
print(f"Cache hit: {result.metadata['from_cache']}")
print(f"Cache key: {result.metadata['cache_key']}")
print(f"Computation time: {result.metadata['compute_time_ms']}ms")
```

**Avantages** :
- ‚úÖ Z√©ro import Bank (abstraction compl√®te)
- ‚úÖ Config cache automatique
- ‚úÖ Validation params int√©gr√©e
- ‚úÖ Metadata cache enrichies
- ‚úÖ API uniforme pour tous indicateurs

---

## üîç EXEMPLE 3 : Sweep param√©trique

### ‚ùå Code actuel (appels directs UnifiedOptimizationEngine)

**Fichier** : `src/threadx/optimization/run.py` ou `src/threadx/ui/sweep.py`

```python
from threadx.optimization.engine import UnifiedOptimizationEngine, DEFAULT_SWEEP_CONFIG
from threadx.indicators.bank import IndicatorBank
import pandas as pd

# Initialisation manuelle
bank = IndicatorBank()
engine = UnifiedOptimizationEngine(
    indicator_bank=bank,
    max_workers=4
)

# Chargement donn√©es
df = pd.read_parquet("data/BTCUSDC_15m.parquet")

# Configuration sweep
sweep_config = {
    'bollinger': {
        'period': [10, 20, 30, 50],
        'std': [1.5, 2.0, 2.5]
    }
}

strategy_config = {
    'name': 'bollinger_mean_reversion',
    'params': {'entry_z': -2.0, 'exit_z': 0.0}
}

# Ex√©cution sweep (bloquant, long)
results = engine.run_sweep(
    data=df,
    sweep_config=sweep_config,
    strategy_config=strategy_config,
    max_workers=4
)

# Tri r√©sultats
best_params = results.sort_values('sharpe_ratio', ascending=False).iloc[0]
print(f"Best params: {best_params['params']}")
print(f"Best Sharpe: {best_params['sharpe_ratio']:.2f}")
```

**Probl√®mes identifi√©s** :
- ‚ùå Import direct `UnifiedOptimizationEngine`
- ‚ùå Gestion manuelle workers
- ‚ùå Ex√©cution bloquante (pas de progress)
- ‚ùå Pas de pruning automatique
- ‚ùå Export manuel r√©sultats

---

### ‚úÖ Code futur (via Bridge)

```python
from threadx.bridge import SweepController, SweepRequest

# Initialisation
controller = SweepController()

# Requ√™te d√©clarative
request = SweepRequest(
    symbol='BTCUSDC',
    timeframe='15m',
    data=df,
    strategy='bollinger_mean_reversion',
    strategy_params={'entry_z': -2.0, 'exit_z': 0.0},
    param_grid={
        'bollinger': {
            'period': [10, 20, 30, 50],
            'std': [1.5, 2.0, 2.5]
        }
    },
    optimization_criteria=['sharpe_ratio', 'total_return', 'max_drawdown'],
    pruning_enabled=True,
    max_workers=4
)

# Ex√©cution avec progress callback (optionnel)
def on_progress(completed, total, current_result):
    print(f"Progress: {completed}/{total} - Current best Sharpe: {current_result:.2f}")

result = controller.run_sweep(
    request,
    progress_callback=on_progress
)

# R√©sultats pr√©-tri√©s et pr√©-prun√©s
print(f"Best params: {result.best_params}")
print(f"Best Sharpe: {result.best_sharpe:.2f}")
print(f"Total combinations tested: {result.total_combinations}")
print(f"Pruned combinations: {result.pruned_count}")

# Export automatique
result.export_to_csv("sweep_results.csv")
result.export_report("sweep_report.html")
```

**Avantages** :
- ‚úÖ Z√©ro import Engine
- ‚úÖ Config workers automatique
- ‚úÖ Progress tracking int√©gr√©
- ‚úÖ Pruning automatique
- ‚úÖ Export simplifi√©

---

## üîç EXEMPLE 4 : Chargement et validation donn√©es

### ‚ùå Code actuel (appels directs data.io)

```python
from threadx.data.io import read_frame
from threadx.data.registry import quick_inventory
import pandas as pd

# Listing manuel
inventory = quick_inventory()
print(f"Available files: {len(inventory)}")

# Chargement manuel
df = read_frame("data/crypto_data_parquet/BTCUSDC_15m.parquet")

# Validation manuelle basique
assert not df.empty, "DataFrame empty"
assert 'close' in df.columns, "Missing close column"
assert df['close'].notna().all(), "Null values in close"

print(f"Loaded {len(df)} rows")
```

**Probl√®mes identifi√©s** :
- ‚ùå Import direct data.io
- ‚ùå Validation manuelle (incomplet)
- ‚ùå Pas de metadata (source, quality, etc.)
- ‚ùå Gestion erreurs basique

---

### ‚úÖ Code futur (via Bridge)

```python
from threadx.bridge import DataController, DataRequest

# Initialisation
controller = DataController()

# Listing simplifi√©
available_data = controller.list_available_data()
for item in available_data:
    print(f"{item.symbol} - {item.timeframe}: {item.row_count} rows")

# Requ√™te avec validation automatique
request = DataRequest(
    symbol='BTCUSDC',
    timeframe='15m',
    validate=True,  # Active validation automatique
    required_columns=['open', 'high', 'low', 'close', 'volume']
)

# Chargement + validation
result = controller.load_data(request)

# R√©sultat avec validation compl√®te
print(f"Loaded {result.row_count} rows")
print(f"Data quality: {result.validation.quality_score}/10")
print(f"Missing values: {result.validation.missing_count}")
print(f"Outliers detected: {result.validation.outlier_count}")
print(f"Date gaps: {result.validation.date_gaps}")

# Acc√®s DataFrame valid√©
df = result.dataframe
```

**Avantages** :
- ‚úÖ Z√©ro import data.io
- ‚úÖ Validation automatique compl√®te
- ‚úÖ Metadata enrichies (quality, gaps, etc.)
- ‚úÖ Gestion erreurs centralis√©e
- ‚úÖ Inventory simplifi√©

---

## üìä COMPARAISON R√âCAPITULATIVE

| Feature | Code actuel (Direct Engine) | Code futur (via Bridge) |
|---------|------------------------------|-------------------------|
| **Imports** | Engine direct | Bridge uniquement |
| **Type safety** | ‚ùå Partial | ‚úÖ Full (DataClasses) |
| **Validation** | ‚ùå Manuelle | ‚úÖ Automatique |
| **Testabilit√©** | üü° Difficile | ‚úÖ Facile (mock Bridge) |
| **Metadata** | ‚ùå Minimale | ‚úÖ Enrichie |
| **Progress tracking** | ‚ùå Non | ‚úÖ Callbacks |
| **Error handling** | üü° Basique | ‚úÖ Custom exceptions |
| **Config management** | ‚ùå Manuelle | ‚úÖ Centralis√©e |
| **Cache visibility** | ‚ùå Opaque | ‚úÖ Transparente |
| **Export results** | ‚ùå Manuel | ‚úÖ M√©thodes int√©gr√©es |

---

## üéØ IMPACT MIGRATION

### Effort par fichier

| Fichier | Lignes impact√©es | Effort | Priorit√© |
|---------|------------------|--------|----------|
| `benchmarks/run_backtests.py` | ~20 lignes | 30 min | üü° Moyen |
| `optimization/run.py` | ~30 lignes | 45 min | üü° Moyen |
| `ui/sweep.py` | ~100 lignes | 3h | üî¥ Haute |
| `apps/streamlit/app.py` | ~50 lignes | 1.5h | üî¥ Haute |

### B√©n√©fices attendus

- ‚ö° **Performance** : Inchang√©e (Bridge = thin wrapper)
- üß™ **Tests** : +50% couverture (mock Bridge facile)
- üîí **Type safety** : +100% (mypy strict compatible)
- üìù **Lisibilit√©** : +80% (requ√™tes d√©claratives)
- üêõ **Debugging** : +60% (exceptions claires)

---

**‚úÖ READY TO IMPLEMENT BRIDGE (Prompt 2)**

*Examples cr√©√©s le 2025-10-14*
